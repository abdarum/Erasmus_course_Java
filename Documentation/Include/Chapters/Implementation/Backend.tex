\subsection{Backend}

\subsubsection{Models}
Models of data were generated using Swagger web app. Definition of all models can be found in section \ref{sec:appendix_a}. For example definition of User class in Swagger model is presented in listing \ref{lst:BackendUserModel}.

\lstinputlisting[firstnumber=931, firstline=931, lastline=976, breaklines=true, numbers=left, stepnumber=1, label={lst:BackendUserModel}, caption={User model}]{Include/Resources/Database/Project/abdarum-libraryVarna.yaml}


It was needed to add annotation from \textit{javax.persistence} like:
\textit{Entity}, \textit{GeneratedValue}, \textit{GenerationType}, \textit{Id}, \textit{Table} to default generated models. These annotations are using to communicate with database properly. Example of setting up code can be seen in listing \ref{lst:BackendModelPersistenceAnnotations}.


\begin{lstlisting}[breaklines=true, numbers=left, stepnumber=1, label={lst:BackendModelPersistenceAnnotations}, caption={Model persistence annotations},language=Java]
@Entity
@Table(name = "book")
@JsonRootName("Book")
public class Book   {
  @Id
  @GeneratedValue(strategy=GenerationType.AUTO)
  @JsonProperty("id")
  private Long id = null;

  @JsonProperty("name")
  private String name = null;
\end{lstlisting}

\subsubsection{Services}
Services are implementation of business logic and all needed manipulation of data in database.

Each of main data segments had implemented needed functionalities. Example book service functionalities are included in listing \ref{lst:BackendBookServicesInterface}. 
\begin{lstlisting}[breaklines=true, numbers=left, stepnumber=1, label={lst:BackendBookServicesInterface}, caption={Book services interface},language=Java]
public interface BookService {
  public Void initBookValues();
  public int countBooks();
  public int countAvailableBooks();
  public Book createBook(Book book);
  public List<Book> getAllBooks();
  public Book deleteBookById(Long id);
  public Book getBookById(Long id);
  public String getBookNameById(Long id);
  public Book updateBookById(Long id, Book body);
  public Boolean updateBookStatus(Long id, StatusEnum status);
  public List<Book> getAllAvailableBooks();
\end{lstlisting}

Services were using JPA repositories to manipulate data stored in database like in listing \ref{lst:BackendUserServiceCreateUser}.
\begin{lstlisting}[breaklines=true, numbers=left, stepnumber=1, label={lst:BackendUserServiceCreateUser}, caption={User service create user},language=Java]
@Override
public User createUser(User user) {
  OffsetDateTime registrated = OffsetDateTime.now(ZoneId.of("UTC"));
  user.setRegistrated(registrated);
  
  Optional<User> od = userRepository.getUserByEmail(user.getEmail());
  if(!od.isPresent()) {
      log.info("Create new user:\n"+user.toString());
      return userRepository.save(user);
  } else {
      log.error("Sorry, user with  given email exist. Email: "+user.getEmail());
  }
  return null;
}	
\end{lstlisting}

\subsubsection{RestAPI}
Models of data were generated using Swagger web app. The RestAPI model was defined in Swagger 2.0 format. Definition of whole RestAPI is included in section \ref{sec:appendix_a}.

Definition of \textit{Create User} method was described in Swagger 2.0 format in listing \ref{lst:BackendRestCreateUserSwaggerDefinition}.

\lstinputlisting[firstnumber=25, firstline=25, lastline=56, breaklines=true, numbers=left, stepnumber=1, label={lst:BackendRestCreateUserSwaggerDefinition}, caption={Create user Swagger 2.0 definition}]{Include/Resources/Database/Project/abdarum-libraryVarna.yaml}

Output generated from Swagger web app was as two files describing RestAPI interface. First was containing interface of RestAPI methods. Example of those functions is in listing \ref{lst:BackendRestCreateUserInterface}.

\begin{lstlisting}[breaklines=true, numbers=left, stepnumber=1, label={lst:BackendRestCreateUserInterface}, caption={Create user interface generated by Swagger},language=Java]
  @ApiOperation(value = "Create user", nickname = "createUser", notes = "This can only be done by the logged in user.", authorizations = {
  @Authorization(value = "bearerAuth")
}, tags={ "user", })
@ApiResponses(value = { 
  @ApiResponse(code = 200, message = "successful operation"),
  @ApiResponse(code = 400, message = "Bad request"),
  @ApiResponse(code = 401, message = "Unauthorized, no access"),
  @ApiResponse(code = 403, message = "Forbidden") })
@RequestMapping(value = "/user",
  consumes = { "application/json" },
  method = RequestMethod.POST)
ResponseEntity<Void> createUser(@ApiParam(value = "Created user object" ,required=true )  @Valid @RequestBody User body,@ApiParam(value = "") @Valid @RequestParam(value = "token", required = false) String token);
\end{lstlisting}

Second file was containing implementation of RestAPI functionalities. Example from this file is listing \ref{lst:BackendRestCreateUserImplementation}. In those implementation usage of different HTTP status codes can be seen.

\begin{lstlisting}[breaklines=true, numbers=left, stepnumber=1, label={lst:BackendRestCreateUserImplementation}, caption={Create user implementation},language=Java]
public ResponseEntity<Void> createUser(@ApiParam(value = "Created user object" ,required=true )  @Valid @RequestBody User body,@ApiParam(value = "") @Valid @RequestParam(value = "token", required = false) String token) {
  String accept = request.getHeader("Accept");
  if (accept != null && (accept.contains("application/json") || accept.contains("*/*")) ){
      if(userService.isModifyPermittedForToken(body, token)){
          body = userService.initNewUserAccordingToPermissions(body, token);
          if(userService.createUser(body) != null){
              return new ResponseEntity<Void>(HttpStatus.OK);
          } else {
              return new ResponseEntity<Void>(HttpStatus.FORBIDDEN);
          }
      } else {
          return new ResponseEntity<Void>(HttpStatus.UNAUTHORIZED);
      }
  } else {
      return new ResponseEntity<Void>(HttpStatus.BAD_REQUEST);
  }
}
\end{lstlisting}
